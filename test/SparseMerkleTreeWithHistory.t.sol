pragma solidity ^0.8.0;

import {PoseidonDeployer} from "../contracts/PoseidonDeployer.sol";
import {SparseMerkleTreeWithHistory} from "../contracts/SparseMerkleTreeWithHistory.sol";
import { Test } from "forge-std/Test.sol";
import {console} from "forge-std/console.sol";
interface IPoseidon {
    function poseidon(uint256[2] calldata inputs) external pure returns (uint256);
}

contract SparseMerkleTreeWithHistoryTestHarness is SparseMerkleTreeWithHistory {
    constructor(uint32 _levels, address _poseidon) SparseMerkleTreeWithHistory(_levels, _poseidon) {}
    function insertLeaf(uint256 _leaf) public returns (uint32 index) {
        return super._insertLeaf(_leaf);
    }
}

// Sanity checking test suite. The code for Poseidon is generated by circomlibjs.
contract SparseMerkleTreeWithHistoryTest is Test {
    IPoseidon poseidon;
    SparseMerkleTreeWithHistoryTestHarness sparseMerkleTreeWithHistory;

    function setUp() public {
        PoseidonDeployer poseidonDeployer = new PoseidonDeployer();
        poseidon = IPoseidon(poseidonDeployer.deploy());
        sparseMerkleTreeWithHistory = new SparseMerkleTreeWithHistoryTestHarness(20, address(poseidon));
    }

    function test_constructor() public {
        assertEq(sparseMerkleTreeWithHistory.levels(), 20);
        assertEq(address(sparseMerkleTreeWithHistory.poseidon()), address(poseidon));
        assertEq(sparseMerkleTreeWithHistory.root(), 15019797232609675441998260052101280400536945603062888308240081994073687793470);
        assertEq(sparseMerkleTreeWithHistory.nextIndex(), 0);
        assertEq(sparseMerkleTreeWithHistory.MAX_LEAVES(), 2**20);
    }

    function test_insertLeaf() public {
        uint256 leaf = 723481756089151327607340146346686737297312916931933480; // Arbitrary leaf value
        uint256 expectedNewRoot = 20625576552796621243774587934918832648838571994147541259749512175658289422488;
        uint256 initialRoot = sparseMerkleTreeWithHistory.root();
        uint32 index = sparseMerkleTreeWithHistory.insertLeaf(leaf);
        assertEq(index, 0);
        assertEq(sparseMerkleTreeWithHistory.root(), expectedNewRoot);
        assertEq(sparseMerkleTreeWithHistory.historicalRoots(initialRoot), true);
        assertEq(sparseMerkleTreeWithHistory.leaves(index), leaf);
        assertEq(sparseMerkleTreeWithHistory.filledSubtrees(0, 0), leaf, "left child");
        assertEq(sparseMerkleTreeWithHistory.filledSubtrees(0, 1), 0, "right child");

        // Test the filled subtrees are updated correctly. Since we know we're only updating the leftmost leaf, we can iterate naively here
        for (uint32 i = 0; i < sparseMerkleTreeWithHistory.levels(); i++) {
            assertEq(sparseMerkleTreeWithHistory.filledSubtrees(i, 0), expectedHashByLevel(i), "left child");
            assertEq(sparseMerkleTreeWithHistory.filledSubtrees(i, 1), 0, "right child");
        }
    }

    // Skipping because it's too slow
    function Xtest_insertLeaf_multiple(uint32 insertions) public {
        // Test that the index loops back and overwrites old leaves
        vm.assume(insertions > 0 && insertions < 2_000_000);
        vm.pauseGasMetering();
        uint256 previousRoot = sparseMerkleTreeWithHistory.root();
        for (uint32 i = 0; i < insertions; i++) {
            uint32 index = sparseMerkleTreeWithHistory.insertLeaf(i);
            assertEq(index, i % sparseMerkleTreeWithHistory.MAX_LEAVES());
            assertEq(sparseMerkleTreeWithHistory.historicalRoots(previousRoot), true);
        }
    }

    function test_computeRoot() public {
        uint256 leaf = 723481756089151327607340146346686737297312916931933480; // Arbitrary leaf value
        uint256[] memory pathElements = new uint256[](20);
        uint256[] memory pathIndices = new uint256[](20);
        uint256 root = sparseMerkleTreeWithHistory.computeRoot(leaf, pathElements, pathIndices);
        assertEq(root, 1290122744831005636502825455403394146804044122337666843344176063641836126315);
    }

    function test_zeros() public {
        uint256 value = 0;
        uint256[2] memory inputs;
        inputs[0] = value;  
        inputs[1] = value;

        for (uint256 i = 1; i < 32; i++) {
            uint256 result = poseidon.poseidon(inputs);
            inputs[0] = result;
            inputs[1] = result;
            assertEq(result, sparseMerkleTreeWithHistory.zeros(i));
        }
    }

    // Efficiency++
    function expectedHashByLevel(uint256 level) private pure returns (uint256) {
        if(level == 0) {
            return 723481756089151327607340146346686737297312916931933480;
        } else if (level == 1) {
            return 6642594246458705100150537824348307752290899718227005220677012577713582822076;
        } else if (level == 2) {
            return 16743898652510945991024241016827777551597930235653541469264784062831611391106;
        } else if (level == 3) {
            return 9237534866145595923970391475517900325846899728611866977854446181538914915491;
        } else if (level == 4) {
            return 7214672762604530548083606399480339905372349176093532154148310369604452101031;
        } else if (level == 5) {
            return 4987000666591808555997449793957822083918360672674515415529063163614305168808;
        } else if (level == 6) {
            return 4617071740581591403161354454903102716397670945178171250362601712940910773243;
        } else if (level == 7) {
            return 15069273613616056992277306246447595922375117157628115335174940963320233714996;
        } else if (level == 8) {
            return 18198181995114282948575690446362708005281191224314856204177871469437156740328;
        } else if (level == 9) {
            return 12912258519964443273017679947165527837129048240665074942297895636189785338690;
        } else if (level == 10) {
            return 9540694078794111009826609777679449168828359367724418367923643382232438971511;
        } else if (level == 11) {
            return 12019528579703802285977756250134897249293602716046111706660759933828332535207;
        } else if (level == 12) {
            return 6421834578035163768783662193873336145217015955600600968424196000366863950233;
        } else if (level == 13) {
            return 2821333830477166520476694746194855542053743011410918820007072710482304991135;
        } else if (level == 14) {
            return 20094752284933334569038186754664059869021012915926131581413688866302251640379;
        } else if (level == 15) {
            return 17036906315404269605174042565890892817358921937144389923505243582822871045158;
        } else if (level == 16) {
            return 14559347513922934484263121314431788683517746654981211158502409977165305511188;
        } else if (level == 17) {
            return 2224609412983355776711665793319913690098648231881472234721919437588945471701;
        } else if (level == 18) {
            return 11979485285596395455052676316492784101241336594677235260314161354031781927293;
        } else if (level == 19) {
            return 4585525978923333018038078700711894248586552832352438164221734300326089621750;
        } else {
            return 0;
        }
    }
}
